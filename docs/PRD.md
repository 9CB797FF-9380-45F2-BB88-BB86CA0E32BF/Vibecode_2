알겠습니다. 모든 질문에 대한 답변이 완료되었습니다. 이 프로젝트의 고유하고 도전적인 요구사항들을 모두 반영하여, AI 코딩 Agent가 즉시 개발에 착수할 수 있을 만큼 상세하고 구조화된 최종 PRD(제품 요구사항 명세서)를 작성했습니다.

더 이상 추가 질문은 필요 없으며, 아래 PRD를 기반으로 프로젝트를 진행할 수 있습니다.

---

## **PRD: AI 실시간 객체 칼로리 추정 서비스**

### **1. 프로젝트 개요 (Overview)**

*   **프로젝트명:** AI 실시간 객체 칼로리 추정 서비스 (Live AI Calorie Estimator)
*   **목표:** 웹 브라우저의 카메라 스트림을 실시간으로 분석하여 화면에 보이는 모든 객체(음식 및 사물)의 이론적 칼로리를 추정하고, 그 결과를 AR(증강현실) 라벨로 객체 위에 오버레이하여 표시한다.
*   **Target Agent:** AI Coding Agent
*   **핵심 특징:**
    *   별도 애플리케이션 설치가 필요 없는 100% 웹 기반 서비스
    *   음식뿐만 아니라 사물, 생물 등 모든 객체의 칼로리 추정
    *   주변의 표준 크기 객체를 이용한 동적 부피 추정 기능
    *   실시간 AR 시각화

### **2. 핵심 사용자 플로우 (Core User Flow)**

1.  사용자가 서비스 웹 페이지에 접속한다.
2.  브라우저가 카메라 접근 권한을 요청한다. 사용자가 '허용'한다.
3.  웹 페이지에 실시간 카메라 영상이 표시된다.
4.  시스템이 영상 프레임을 지속적으로 분석하여 화면 내 객체들을 인식(Detection & Classification)한다.
5.  인식된 각 객체에 대해 부피를 추정한다.
6.  인식된 각 객체의 종류(음식/사물)를 판별하고, 그에 맞는 로직으로 칼로리를 계산한다.
7.  계산된 결과(객체명, 칼로리, 주요 영양성분)를 각 객체의 위치에 AR 라벨 형태로 오버레이한다. 라벨은 객체의 움직임을 따라 실시간으로 위치를 갱신한다.
8.  사용자가 브라우저 탭을 닫으면 서비스가 종료된다. 데이터는 저장되지 않는다.

### **3. 기능 요구사항 (Functional Requirements)**

#### **FR-1: 웹 환경 및 카메라 제어**
*   **FR-1.1:** WebRTC의 `getUserMedia` API를 사용하여 사용자의 전면 또는 후면 카메라에 접근해야 한다.
*   **FR-1.2:** 모바일과 데스크톱 웹 브라우저에서 모두 동작하는 반응형 UI를 구현해야 한다.

#### **FR-2: 실시간 객체 인식**
*   **FR-2.1:** 영상 스트림 내에 존재하는 다수의 객체를 동시에 탐지하고 각 객체의 경계 상자(Bounding Box)를 식별해야 한다.
*   **FR-2.2:** 탐지된 각 객체를 분류(Classification)하여 객체의 이름(Class Name)을 특정해야 한다. (예: `apple`, `laptop`, `cat`)
*   **FR-2.3:** 인식 대상은 음식에 국한되지 않고, 일반 사물, 동식물을 포함한 '모든 객체'를 대상으로 한다.

#### **FR-3: 부피 추정 로직 (Decision Tree)**
*   **FR-3.1: [우선순위 1] 기준 객체 기반 추정**
    *   **FR-3.1.1:** 다음의 기준 객체 목록(Reference Object List)을 사전에 정의하고, 표준 크기 데이터를 내장한다: `신용카드`(85.6x54mm), `A4용지`(297x210mm), `100원 동전`(지름 24mm), `BIC 라이터`.
    *   **FR-3.1.2:** 영상 프레임 내에서 기준 객체가 인식되면, 해당 객체의 픽셀 크기를 기반으로 '실제 mm 당 픽셀 수(pixel-per-metric ratio)'를 계산한다.
    *   **FR-3.1.3:** 계산된 비율을 사용하여 화면 내 다른 객체들의 실제 부피(가로, 세로, 추정 깊이)를 추정한다.
*   **FR-3.2: [우선순위 2] 표준 1인분 기반 추정**
    *   **FR-3.2.1:** 프레임 내에 기준 객체가 없을 경우 이 로직을 실행한다.
    *   **FR-3.2.2:** 인식된 객체가 '음식'일 경우, '표준 1인분'으로 양을 가정한다.
    *   **FR-3.2.3:** 인식된 객체가 '사물'일 경우, 해당 사물 분류의 평균적인 크기를 기준으로 부피를 가정한다.

#### **FR-4: 칼로리 추정 로직 (Decision Tree)**
*   **FR-4.1:** 인식된 객체(`Class Name`)가 '음식'인지 '사물'인지 판별한다. (1차적으로 식품 DB API에 해당 이름이 있는지 여부로 판단)
*   **FR-4.2: [Case A] 객체가 '음식'일 경우**
    *   **FR-4.2.1:** '식품의약품안전처_식품영양성분DB' API를 호출하여 해당 음식의 100g당 표준 영양 정보(칼로리, 탄수화물, 단백질, 지방)를 조회한다.
    *   **FR-4.2.2:** FR-3에서 추정한 부피와 해당 음식의 평균 밀도를 사용하여 무게를 계산하고, 최종 칼로리와 영양성분을 산출한다.
*   **FR-4.3: [Case B] 객체가 '사물' 또는 '생물'일 경우 (이론적 칼로리 추정)**
    *   **FR-4.3.1:** 사물-물질 매핑 테이블을 내장한다. (예: `책`->`종이(셀룰로스)`, `플라스틱 컵`->`폴리에틸렌`, `고양이`->`유기물(단백질, 지방 혼합)`)
    *   **FR-4.3.2:** 주요 물질별 g당 이론적 열량 데이터를 내장한다. (예: `셀룰로스`: ~4kcal, `단백질`: 4kcal, `지방`: 9kcal)
    *   **FR-4.3.3:** FR-3에서 추정한 부피와 해당 물질의 평균 밀도를 사용하여 무게를 계산하고, 최종 이론적 칼로리를 산출한다.

#### **FR-5: AR 시각화**
*   **FR-5.1:** 인식된 모든 객체의 Bounding Box 위에 HTML/CSS 기반의 정보 라벨을 오버레이한다.
*   **FR-5.2:** 라벨 표시 형식:
    > **[객체 이름]**
    > **[추정 칼로리] kcal**
    > 탄수화물: Xg, 단백질: Yg, 지방: Zg
*   **FR-5.3:** '사물'의 경우, 영양성분은 'N/A' 또는 이론적 구성성분 비율로 표시한다.
*   **FR-5.4:** AR 라벨은 객체가 화면 내에서 움직일 때 실시간으로 위치를 추적해야 한다.

### **4. 비기능 요구사항 (Non-Functional Requirements)**

*   **성능:** 전체 인식-분석-표시 파이프라인은 초당 10프레임(10 FPS) 이상으로 처리되어야 한다.
*   **호환성:** 최신 버전의 Chrome, Safari (iOS), Firefox 브라우저에서 정상 동작해야 한다.
*   **개인정보보호:** 서버로 이미지를 전송할 경우, 분석 목적 외에 절대 저장해서는 안 되며, 가급적 모든 AI 연산은 클라이언트 측(브라우저)에서 처리하는 것을 권장한다.

### **5. 기술 스택 및 아키텍처 (Tech Stack & Architecture)**

*   **Frontend:** HTML5, CSS3, JavaScript (ES6+)
*   **AI/ML:** **TensorFlow.js**. 클라이언트 측에서 실시간 추론을 수행하여 속도와 개인정보보호를 확보한다.
*   **AR 구현:** `AR.js` 또는 `Three.js`를 사용하거나, CSS 3D Transform을 이용해 2D 영상 위에 HTML 요소를 오버레이하는 방식을 사용한다.
*   **아키텍처 제안 (Hybrid Model):**
    1.  **Client-side (TensorFlow.js):** 가벼운 객체 탐지 모델(예: MobileNet-SSD, YOLO Lite)을 사용하여 실시간으로 객체의 위치와 기본적인 분류를 수행한다.
    2.  **Server-side (Optional):** 클라이언트에서 분류가 불확실하거나, 더 정밀한 분석이 필요하다고 판단될 경우(예: 처음 보는 음식), 해당 프레임만 서버로 보내 강력한 모델(예: EfficientNet)로 분석 후 결과만 다시 받아온다. 이는 정확도와 실시간성 사이의 균형을 맞추기 위함이다.

### **6. 외부 의존성 (External Dependencies)**

*   **API:** 식품의약품안전처 식품영양성분 DB API (인증키 필요)
*   **AI 모델:** TensorFlow Hub 또는 유사한 소스에서 사전 훈련된 객체 탐지 모델 (COCO 데이터셋 기반 모델 등)
*   **내부 DB 구축 필요:**
    *   기준 객체(Reference Object)의 표준 크기 데이터
    *   사물-물질 매핑 테이블 및 물질별 칼로리/밀도 데이터